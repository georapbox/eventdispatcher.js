{"version":3,"sources":["eventDispatcher.js"],"names":["name","context","definition","define","amd","module","exports","this","errors","nonExtensible","eventDispatcherPrototype","addEventListener","type","listener","listeners","Object","isExtensible","TypeError","_listeners","indexOf","push","hasEventListener","removeEventListener","listenerArray","index","splice","dispatchEvent","event","i","length","target","call","eventDispatcher","create","apply","value","object"],"mappings":";;;;;;;;;CAIC,SAAUA,EAAMC,EAASC,GACxB,YAEsB,mBAAXC,SAAyBA,OAAOC,IACzCD,OAAOD,GACoB,mBAAXG,SAA0BA,OAAOC,QACjDD,OAAOC,QAAUJ,IAEjBD,EAAQD,GAAQE,EAAWF,EAAMC,IAEnC,kBAAmBM,KAAM,SAAUP,GACnC,YAEA,IAAIQ,IACFC,cAAe,iBAAmBT,EAAO,iCAGvCU,GAUFC,iBAAkB,SAAUC,EAAMC,GAChC,GAAIC,EAEJ,KAAKC,OAAOC,aAAaT,MACvB,KAAM,IAAIU,WAAUT,EAAOC,cAiB7B,OAd+B,mBAApBF,MAAKW,aACdX,KAAKW,eAGPJ,EAAYP,KAAKW,WAEc,mBAApBJ,GAAUF,KACnBE,EAAUF,OAGRE,EAAUF,GAAMO,QAAQN,MAAc,GACxCC,EAAUF,GAAMQ,KAAKP,GAGhBN,MAWTc,iBAAkB,SAAUT,EAAMC,GAChC,GAAIC,EAEJ,OAA+B,mBAApBP,MAAKW,aAIhBJ,EAAYP,KAAKW,WAEc,mBAApBJ,GAAUF,IAAyBE,EAAUF,GAAMO,QAAQN,MAAc,IAetFS,oBAAqB,SAAUV,EAAMC,GACnC,GAAIC,GAAWS,EAAeC,CAE9B,IAA+B,mBAApBjB,MAAKW,WAehB,MAXAJ,GAAYP,KAAKW,WACjBK,EAAgBT,EAAUF,GAEG,mBAAlBW,KACTC,EAAQD,EAAcJ,QAAQN,GAE1BW,KAAU,GACZD,EAAcE,OAAOD,EAAO,IAIzBjB,MAUTmB,cAAe,SAAUC,GACvB,GAAIb,GAAWS,EAAeK,EAAGC,CAEjC,IAA+B,mBAApBtB,MAAKW,WAAhB,CAOA,GAHAJ,EAAYP,KAAKW,WACjBK,EAAgBT,EAAUa,EAAMf,MAEH,mBAAlBW,GAKT,IAJAI,EAAMG,OAASvB,KAEfsB,EAASN,EAAcM,OAElBD,EAAI,EAAGA,EAAIC,EAAQD,GAAK,EAC3BL,EAAcK,GAAGG,KAAKxB,KAAMoB,EAIhC,OAAOpB,SAIPyB,EAAkBjB,OAAOkB,OAAOvB,GAClCwB,OASEC,MAAO,SAA8BC,GACnC,IAAKrB,OAAOC,aAAaoB,GACvB,KAAM,IAAInB,WAAUT,EAAOC,cAQ7B,OALA2B,GAAOzB,iBAAmBD,EAAyBC,iBACnDyB,EAAOf,iBAAmBX,EAAyBW,iBACnDe,EAAOd,oBAAsBZ,EAAyBY,oBACtDc,EAAOV,cAAgBhB,EAAyBgB,cAEzCnB,QAKb,OAAOyB","file":"eventDispatcher.min.js","sourcesContent":["/**\n * @module eventDispatcher\n * @desc JavaScript events for custom objects\n */\n(function (name, context, definition) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    define(definition);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = definition();\n  } else {\n    context[name] = definition(name, context);\n  }\n}('eventDispatcher', this, function (name) {\n  'use strict';\n\n  var errors = {\n    nonExtensible: 'Cannot apply \"' + name + '\" on an non extensible object'\n  };\n\n  var eventDispatcherPrototype = {\n    /**\n     * Registers the specified `listener` on the event target it's called on.\n     *\n     * @function addEventListener\n     * @param {String} type A string representing the event type to listen for.\n     * @param {function} listener A function to be executed when an event of the specified `type` occurs.\n     * @throws {TypeError} If the object that `eventDispatcher` is applied to is not extensible.\n     * @return {Object} The `eventDispatcher` object.\n     */\n    addEventListener: function (type, listener) {\n      var listeners;\n\n      if (!Object.isExtensible(this)) {\n        throw new TypeError(errors.nonExtensible);\n      }\n\n      if (typeof this._listeners === 'undefined') {\n        this._listeners = {};\n      }\n\n      listeners = this._listeners;\n\n      if (typeof listeners[type] === 'undefined') {\n        listeners[type] = [];\n      }\n\n      if (listeners[type].indexOf(listener) === - 1) {\n        listeners[type].push(listener);\n      }\n\n      return this;\n    },\n\n    /**\n     * Checks if the target object has a `listener` registered on for specific event `type`..\n     *\n     * @function hasEventListener\n     * @param {String} type A string representing the event type.\n     * @param {function} listener The event listener to check if registered for the specified event `type`.\n     * @return {Boolean} True if target object has `listener` registered for specific event `type`; otherwise false.\n     */\n    hasEventListener: function (type, listener) {\n      var listeners;\n\n      if (typeof this._listeners === 'undefined') {\n        return false;\n      }\n\n      listeners = this._listeners;\n\n      if (typeof listeners[type] !== 'undefined' && listeners[type].indexOf(listener) !== - 1) {\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Removes the previously registered event `listener` from the event target.\n     *\n     * @function removeEventListener\n     * @param {String} type A string representing the event type to remove.\n     * @param {function} listener The event listener function to remove from the event target.\n     * @return {Object} The `eventDispatcher` object.\n     */\n    removeEventListener: function (type, listener) {\n      var listeners, listenerArray, index;\n\n      if (typeof this._listeners === 'undefined') {\n        return;\n      }\n\n      listeners = this._listeners;\n      listenerArray = listeners[type];\n\n      if (typeof listenerArray !== 'undefined') {\n        index = listenerArray.indexOf(listener);\n\n        if (index !== - 1) {\n          listenerArray.splice(index, 1);\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Dispatches an event at the specified event target.\n     *\n     * @function dispatchEvent\n     * @param {Object} event The event object to be dispatched.\n     * @return {Object} The `eventDispatcher` object.\n     */\n    dispatchEvent: function (event) {\n      var listeners, listenerArray, i, length;\n\n      if (typeof this._listeners === 'undefined') {\n        return;\n      }\n\n      listeners = this._listeners;\n      listenerArray = listeners[event.type];\n\n      if (typeof listenerArray !== 'undefined') {\n        event.target = this;\n\n        length = listenerArray.length;\n\n        for (i = 0; i < length; i += 1) {\n          listenerArray[i].call(this, event);\n        }\n      }\n\n      return this;\n    }\n  };\n\n  var eventDispatcher = Object.create(eventDispatcherPrototype, {\n    apply: {\n      /**\n       * Applies the `eventDispatcher` prototype methods to the event target.\n       *\n       * @function apply\n       * @param {Object} object The event target object.\n       * @throws {TypeError} If the object that `eventDispatcher` is applied to is not extensible.\n       * @return {Object} The `eventDispatcher` object.\n       */\n      value: function applyEventDispatcher(object) {\n        if (!Object.isExtensible(object)) {\n          throw new TypeError(errors.nonExtensible);\n        }\n\n        object.addEventListener = eventDispatcherPrototype.addEventListener;\n        object.hasEventListener = eventDispatcherPrototype.hasEventListener;\n        object.removeEventListener = eventDispatcherPrototype.removeEventListener;\n        object.dispatchEvent = eventDispatcherPrototype.dispatchEvent;\n\n        return this;\n      }\n    }\n  });\n\n  return eventDispatcher;\n}));\n"],"sourceRoot":"/source/"}